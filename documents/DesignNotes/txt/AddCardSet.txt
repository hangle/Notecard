AddCardSet (Notecard)
=======================

The script shows a two CardSets beginning the the 'c' (clear)  
command and a Add-CardSet beginning with a 'b' command ('b'  
also clears the screen):   

		c
		d I am a card set

		b
		d I am an add card set

		c
		d I am a second card set

		* end

All three CardSets are terminated by button activation. Notecard  
buttons consist of the following:  

		*, +Add, Prior, and Next

In the first CardSet with the display 'I am a card set', activation  
of the Next button presents the second CardSet with the display 'I  
am a second card set'.  The Add-CardSet is skipped without   
displaying 'I am an add card set'.   

One or more Add-CardSets that immediately follow a CardSet are  
controlled by the +Add button.  While 'I am a card set' is  
shown, then activation of the +Add button clear the screen and  
displays 'I am an add card set'.  A second activation of the  
+Add button terminates the Add-CardSet because the linked list  
of the one Add-CardSet has ended.  

Following the screen erasurer of 'I am an add card set',  
the initial CardSet with the display 'I am a card set' is  
reactivated.   

In the case where there are two or more immediate Add-CardSets,   
the +Add button would activate the multiple Add-CardSets.  
Activation, of the Next button would, however, terminate   
the Add-CardSets.  

The AddCardSet with the beginning 'b' tag is associated with   
the CardSet with the begnning 'c' tag.  Both the 'c' and 'b'    
commands have the same functionality of clearing the screen.    

A CardSet having an associated AddCardSet arms its '+Add'   
button; the button color becomes yellow.  Activating this button   
executes the AddCardSet.  Waiting for the 'Next' button to   
be armed and activating it causes the AddCardSet to be    
skipped.    

Approach
--------

Notecard  execution is based on a linked list structure of   
commands where there is a hierarchy of four sublists and   
four parent classes for the four sublists:   

		Notecard
		CarsSet
		RowerNode
		BoxField

CardSet, RowerNode, and BoxField parent classes have two    
variables that hold physical addresses to other class types:   

		child           // starting address of sublist
		sibling         // address of next member in
				// the current sublist

The CardSet class has an additional physical address variable:   

		button		// starting address of AddCardSet

The script program treated the AddCardSet as if it was   
a CardSet.  At the end, AddCardSet elements are removed     
from the linked list heirarchy and assigned to the 'button'      
address variables.  The sibling address of CardSet with an    
associated AddCardSet is changed to point to next sibling   
remaining in the heirarchy.   

Note, a CardSet may have two or more associated AddCardSet   
members. Thus it is appropriate to indicate that the button   
variable of CardSet holds a sublist of AddCardSet members.   
	
Notecard's input file '*.struct' distinguishes CardSet and   
AddCardSet by different classnames:   

		%CardSet
		%AddCardSet

'CreateClass.create_object(...)' removed this distinction    
by instantiating a CardSet object for both:   

		case "%CardSet" | "%AddCardSet" =>
			val cardSet=CardSet(symbolTable)

The common CardSet object maintains the distinction via   
the 'button' address variable; either it is zero (0) or   
it has a physical address value of a AddCardSet.    
'CardSet.isAddCardSet' return true when a physical   
address is present.    

'Notecard' iterates its children and invokes    
'executeNotecardChildren(...):   

		def iterateNotecardChildren(...)
			reset(getFirstChild)
			while(iterate) {
				...
				executeNotecardChildren(...)
				}

		def executeNotecardChildren(obj:Any, ...)
			obj match	{
		    		case cs:CardSet=> 
					if(cs.isAddCardSet) 
						buttonSet.armAddCardSet		
					...
					cs.startCardSet(...)
					waitOverDoButtons(..., cs, ...)

			case ft:NotecardTask=> ...
			case nf:NextFile => ...
			...

If the CardSet object has an associated AddCardSet, then the   
'+Add' button is colored yellow (armAddCardSet).  Next, the    
parent CardList processes its sublist of children:   

		cs.startCardSet(...)

The 'waitOverDoButton(...)' test whether the user activated the   
'Next' or the '+Add' button.  In the case of the '+Add' button,   
the 'doAddCardSet' function is invoked.     

		...
		val button= cs.getAddCardSet 
		val buttonCardSet= button.asInstanceOf[CardSet]
		reset(buttonCardSet)		// Linker trait
		while(iterate) {		// Linker trait
		    Value match {
			case bcs:CardSet=>
				bcs.startCardSet(...)
		...	

The 'cs.getAddCardSet' returns CardSet's button:Node value.    
The asInstanceOf[CardSet] expression converts it to a CardSet object     
which is the associated AddCardSet. 'bsc.startCardSet(...) is   
invoked to executed this particular CardSet.   

Two Notecard function have similar code:   

		def iterateNotecardChildren(...)
			reset(getFirstChild)
			while(iterate) {

		def doAddCardSet(..., cs, ...) 
                        ...
			reset(buttonCardSet)	
			while(iterate) {

When 'doAddCardSet' terminates, then the stack will unwind to   
the 'while(iterate)' loop in 'iterateNotecardChildren'. Unfortunately,  
as shown, this loop will not point to the initial CardSet object which   
is in the linked list hierarchy.  The 'reset(buttonCardSet)' switched    
the pointer to the '+Add' button that was removed from the heirarchy.    

Before 'reset(buttonCardSet)' was executed, the 'cs' value was saved     
and following the while loop, it was restored.  Restoring the value   
allows the inital CardSet to redisplayed.   
