AddCardSet (Notecard)
=======================

The script shows a CardSet and a AddCardSet: 

		c
		d I am a card set

		+
		d I am a button card set

		* end
	
The AddCardSet with the beginning '+' tag is associated with   
the CardSet with the begnning 'c' tag.  Both the 'c' and '+'    
commands have the same functionality of clearing the screen.    

A CardSet having an associated AddCardSet arms its '+Add'   
button; the button color becomes yellow.  Activating this button   
executes the AddCardSet.  Waiting for the 'Next' button to   
be armed and activating it causes the AddCardSet to be    
skipped.    

Approach
--------

Notecard  execution is based on a linked list structure of   
commands where there is a hierarchy of four sublists and   
four parent classes for the four sublists:   

		Notecard
		CarsSet
		RowerNode
		BoxField

CardSet, RowerNode, and BoxField parent classes have two    
variables that hold physical addresses to other class types:   

		child           // starting address of sublist
		sibling         // address of next member in
					//   the current sublist

The CardSet class has an additional physical address variable:   

		button		// starting address of AddCardSet

The script program treated the AddCardSet as if it was   
a CardSet.  At the end, AddCardSet elements are removed    
from the linked list heirarchy and assigned to the 'button'    
address variables.  The sibling address of CardSet with an    
associated AddCardSet is changed to point to next sibling   
remaining in the heirarchy.   

Note, a CardSet may have two or more associated AddCardSet   
members. Thus it is appropriate to indicate that the button   
variable of CardSet holds a sublist of AddCardSet members.   
	
Notecard's input file '*.struct' distinguishes CardSet and   
AddCardSet by different classnames:   

		%CardSet
		%AddCardSet

'CreateClass.create_object(...)' removed this distinction    
by instantiating a CardSet object for both:   

		case "%CardSet" | "%AddCardSet" =>
			val cardSet=CardSet(symbolTable)

The common CardSet object maintains the distinction via   
the 'button' address variable; either it is zero (0) or   
it has a physical address value of a AddCardSet.    
'CardSet.isAddCardSet' return true when a physical   
address is present.    

'Notecard' iterates its children and invokes    
'executeNotecardChildren(...):   

		def iterateNotecardChildren(...)
			reset(getFirstChild)
			while(iterate) {
				...
				executeNotecardChildren(...)
				}

		def executeNotecardChildren(obj:Any, ...)
			obj match	{
		    		case cs:CardSet=> 
					if(cs.isAddCardSet) 
						buttonSet.armAddCardSet		
					...
					cs.startCardSet(...)
					waitOverDoButtons(..., cs, ...)

			case ft:NotecardTask=> ...
			case nf:NextFile => ...
			...

If the CardSet object has an associated AddCardSet, then the   
'+Add' button is colored yellow (armAddCardSet).  Next, the    
parent CardList processes its sublist of children:   

		cs.startCardSet(...)

The 'waitOverDoButton(...)' test whether the user activated the   
'Next' or the '+Add' button.  In the case of the '+Add' button,   
the 'doAddCardSet' function is invoked.     

		...
		val button= cs.getAddCardSet 
		val buttonCardSet= button.asInstanceOf[CardSet]
		reset(buttonCardSet)		// Linker trait
		while(iterate) {		// Linker trait
		    Value match {
			case bcs:CardSet=>
				bcs.startCardSet(...)
		...	

The 'cs.getAddCardSet' returns CardSet's button:Node value.    
The asInstanceOf[CardSet] expression converts it to a CardSet object     
which is the associated AddCardSet. 'bsc.startCardSet(...) is   
invoked to executed this particular CardSet.   

Two Notecard function have similar code:   

		def iterateNotecardChildren(...)
			reset(getFirstChild)
			while(iterate) {

		def doAddCardSet(..., cs, ...) 
                        ...
			reset(buttonCardSet)	
			while(iterate) {

'doAddCardSet' terminates, then the stack will unwind to   
the 'while(iterate)' loop in 'iterateNotecardChildren'. Unfortunately,  
as shown, this loop will not point to the initial CardSet object which   
is in the linked list hierarchy.  The 'reset(buttonCardSet)' switched    
the pointer to the '+Add' button that was removed from the heirarchy.    

Beore 'reset(buttonCardSet)' was executed. the 'cs' value was saved     
and following the while loop, it was restored.  Restoring the value   
allows the inital CardSet to redisplayed.   
